# 외대 종강시계 고민했던 부분들

## 1. `Chrome.storage` vs `localStorage` - chrome.storage
- 학번, 이름, 종강시간 정보, 커스텀 배경화면 등은 브라우저의 스토리지를 이용하여 저장하고, 서비스하고 있다.

### Chrome.Storage
- 따로 익스텐션을 설치하지 않는 이상 유저가 접근할 수 없다 
- 데이터를 객체로 저장할 수 있다.
- API가 전반적으로 localStorage보다 다채롭고 유용하다.
    - getItem 인자로 객체를 사용할 수도 있다.
    - 쓸 일은 아마 없을 것 같지만 스토리지의 데이터가 변할때 이벤트 핸들러를 달아줄 수도 있다.
- 읽고 쓰는 것이 경우 비동기로 처리되기 때문에 로컬스토리지처럼 로직을 블락하지 않고, 더 빠르다고 한다.

### localStorage
- 문자열로만 저장 가능
- 유저가 개발자도구로 접근 가능
- Redux Persist 같은 라이브러리를 사용할 수 있다. chrome.storage용으로 나온 Redux Persist 라이브러리가 없지는 않은데 스타수도 적고 사람들이 많이 쓰는 라이브러리같지 않아서 도입할 수 없을 것 같다.
- Cypress같은 E2E 테스트를 적용할 때 chrome.storage를 사용할 수 없어 웹으로 빌드한다음에 로컬스토리지를 사용하는, 기본적인 웹사이트의 형식으로 테스트가 가능하다

### 결론

Chrome.Storage를 사용한다.

- API의 사용성이 더 좋고, 객체로 데이터를 저장할 수 있어 개발이 더 편해질 것이다.
- 현재 배경화면을 base64로 인코딩하여 스토리지에 넣고 서빙하고 있어 1MB가 넘는 데이터를 스토리지에 저장해야 하는 일도 있다. 더 빠른 쪽을 선택하는게 좋지 않을까 싶다.
- 뒤에서도 또 설명할거 같긴 한데 E2E테스트를 도입하지 않고 Storybook을 이용할 것 같아 굳이 웹에서 프로그램을 돌릴지 잘 모르겠다. => 혹시 나중에 ChromeStorage를 LocalStorage로 스위치할 수 있게끔 개발하면 좋지 않을까..?

## 2. webpack vs rollup - webpack

- 일단 fully configurable한 프로젝트를 위해서 번들링하는 보일러 플레이트부터 만들 예정이었다.
- 롤업이 트리 쉐이킹에 유리하고(ESM 번들링), 번들 크기가 웹팩보다 더 적은 편이라고 알고 있어서 롤업으로 리액트 + 크롬 익스텐션 보일러 플레이트를 세팅해 먼저 만들어보고, 후에 웹팩으로도 만들어봐서 사용성이나 프로젝트 확장 가능성 등을 비교해보고자 했다.
- 롤업 코드는 이렇게 생겼다.

### 결론

사용성과 편리성 면에서 웹팩이랑 많은 차이가 나서, 결국 웹팩을 쓰기로 했다. 모든걸 다 테스트해본건 아니지만 일단 느낀 느낌은 이럼.

- 전체적으로 롤업은 웹개발을 위한 편의 기능이 웹팩보다 부족하다.
- **HTML에 JS 주입해서 결과물 만드는게 불편** : 롤업에 관련 플러그인이 있지만, 모든 번들 결과물을 HTML에 붙이는 것만 가능하고 템플릿 적용이 어렵다. 크롬 익스텐션에는 background.js라는 앱의 일부는 아니지만 크롬 익스텐션 백그라운드에서 돌아가는 코드 번들이 있는데, 이 번들은 HTML에 들어가면 안 되었다.  번들 결과물들을 순회하여 background.js만 빼놓고 HTML에 삽입하거나 하는 로직은 가능하지만 너무 복잡한 것 같음
- **SplitChunks 옵션이 더 좋음** : 롤업에도 manualChunks라고 번들링 결과물을 나눠주는 기능이 있기는 한데 SplitChunks옵션보다 추상화 단계가 낮은 느낌이 있다. 함수와 모듈에 대한 메타 정보를 토대로 내 입맛에 맞게 번들 스플리팅을 할 수 있을듯 싶었음. 공통 모듈을 빼주는 기능을 코드로 구현할 수 있겠지만 Webpack을 사용하면 간단하게 몇가지 옵션만으로 가능해서 굳이 manualChunks를 커스텀하는데 리소스를 써야 할까 싶었다.
- Bundle Analyzer : 번들 아날라이저가 웹팩 쪽이 더 보기가 편했음

## 3. Code Splitting Strategy

- 내가 만드려는 번들의 목표 : 프레임워크, 가장 최초로 불러와지는 메인 번들 하나, 탭 코드 스플리팅(2개), 모드 변경 코드 스플리팅(1개)
- 코드 스플리팅하면 여러개의 번들이 만들어질텐데, 이때 splitchunks 옵션이 없으면 동적 임포트된 번들들은 각각 같은 라이브러리를 포함하고 있을 수 있음!
- 코드 스플리팅된 여러개의 번들 중 공통 번들은 다른 번들로 분리하여 한번만 가져올 수 있도록 하면 될 것 같다.
- 이렇게 생각을 해보니, 정말 앱의 속성에 따라 번들링 전략은 많이 달라질수도 있겠다.. 하늘 아래 같은 웹팩 세팅이 있을까 하는 생각도 들었다.

## 4. Client State, Server State - React Query, Recoil

- React Query와 함께 Recoil을 같이 쓸 것이다. Server State에 직접 접근해야 할 때는 useQuery를 이용하고, Client State 관리는 Recoil로 한다.
- Recoil의 Effect가 상당히 인상적이다. 정말 적은 코드로 Chrome.storage를 Recoil의 Atom들과 정말 쉽고 간편하게 integration 할 수 있다는 점이 넘 훌륭하다...
- 이 서비스는 회원가입도 없고 DB에 유저 정보를 저장하지 않기 때문에 유저의 개인화된 데이터들은 모두 chrome.storage에 저장된다. 이 Storage 데이터 같은 경우 필요할 때 직접 접근하여 받아오는 방식을 생각했지만 상태 관리의 흐름속에 넣고 제어하는게 더 좋을 것이라고 생각이 들었다. 그래서 Recoil을 쓴다.
    - 어떤 하나의 유저 데이터가 여러 컴포넌트에서 동시에 사용 될 가능성을 배제할 수 없다.
    - 동시에 사용되는 유저 데이터의 변경이 일어난다면, 그게 모든 컴포넌트에 반영되어야 한다.
- 물론 Recoil 하나만으로도 비동기 쿼리를 작성할 수 있고 Suspense랑도 연동된다. 하지만 Query Refresh, Fresh/Stale 상태로 하는 캐싱 제어, Server State와 Client State를 잘 분리할 수 있다는 장점이 있기 때문에 React Query를 사용할 것이다. 

## 5. 테스트 전략 - Jest(유닛, 통합 테스팅), Storybook(UI 테스팅)

뷰를 이루는 모듈들의 동작이 완벽하면 뷰도 완벽할 것이다! 아마도..?

### 테스트 규칙

- 리팩토링 책에서 보았듯 "걱정스러운 부분에 더 많은 테스트를 붙여라"
- 라이브러리의 동작을 테스팅하지 않는다(React가 이벤트를 잘 발생시키나? Prop이 잘 들어갔나? 같은거. 라이브러리를 못 믿었다면 애초에 쓰지 말아야 한다. 그리고 well-known 라이브러리들은 라이브러리단에서 이미 테스트 검증이 끝났을 것이다.)
- 컴포넌트 내부를, UI와 의존성이 높은 방식으로 테스팅하지 않는다 : UI에 의존하는 테스트를 만들면, 쉽게 깨지는 테스트가 되고 유지보수 비용도 상승한다. TestLibary나 Enzyme등을 통해 UI를 렌더링해 테스팅하지 않고, Storybook을 사용해 정확한 UI가 렌더링되는지 판단한다.
- Recoil이나 ReactQuery 로직은 만약에 Selector가 QUeryFn이 좀 복잡하게 작동한다면 테스트해볼 수 있을 듯 하다.
- 컴포넌트 테스트로 검증할 수 밖에 없는 부분도 있을까..? 하는 의문이 있는데 계속 생각해 봐야겠다.

### 테스트 종류

- 유닛 테스트와 TDD : Data 가공 관련 로직들, 종단 관심사를 포함하고 있는 Utils 로직들은 컴포넌트와 분리하여 되도록이면 순수 함수로 만들고 유닛 테스트를 한다. 유닛 테스트들은 기능 개발 이전에 먼저 테스트케이스를 작성하고 테스트를 충족시키며 개발을 하는 TDD 방법론을 따른다.
- 통합 테스트 : 유닛 테스트와 조금 그 경계가 헷갈리는 지점이 있다.
- Storybook을 이용한 UI 테스트 :
    - Fundamental : 앱의 기본 단위가 되는 가장 작은 크기의 컴포넌트들을 addon knobs를 통해 쉽게 테스트 가능하게 스토리를 작성한다.
    - User Interaction : 유저 인터렉션에 따라 페이지에서 뷰가 달라지는 부분들에 대해서만 페이지 스토리를 작성한다. Storybook 작성이 쉽지 않은 컴포넌트도 있을 텐데 그거는 해보면서 대책을 강구하자
- 스토리북은 따로 배포해두고, 포트폴리오의 한 부분으로 같이 가져갈 수 있었음 좋겠다.

## 6. CSS-in-JS - Emotion

- Styled Component보다 Emotion의 CSS Props를 사용해보면 어떨까 생각했다.
- emotion이 더 개발자 친화적인 느낌이 든다는데에 동의한다.
- Styled Component를 작성하면서 맘에 안 들었던 것이 바로 Styled Component도 이름이 필요하다는 것이었는데..
이것 때문에 전 회사에서는 컨벤션을 정하기도 하고, 같은 스코프에 같은 이름을 쓰는 것은 또 안 되었다.
CSS Props는 그런 지점을 해결해주는 듯 보인다.
- 그리고 원래 무슨 태그인지 네이밍을 가리지 않기 때문에 어떤 태그인지 더 잘 보인다.
- 디버깅에 유리한 점도 마음에 든다. Emotion은 개발 모드에서 기존 CSS-props의 이름을 실제 렌더링되는 태그에 노출시킨다.
- 일단 Emotion이 번들이 더 작고 기능별로 분리되어 있어 확장성이 좋다. 필요한 경우 styled도 사용할 수 있다는 점에서도 유연하다.
- [성능 면](https://www.youtube.com/watch?v=MN3RWhGudvw)에서 Emotion이 Styled Component랑은 큰 차이가 없는 듯 하다.

## 7. Semantic Tag, Web Accesibility

스크린리더 사용자가 앱을 사용하는데 불편함이 없도록 웹 접근성을 고려한 마크업을 작성한다.
사용할 Tag들, 웹 접근성을 보장하기 위한 전략들은 다음과 같다.

- p : 기본적인 문단은 p 태그로 표시한다.
- a : 링크, 클릭해서 다른 화면으로 넘어갈 수 있는 경우 무조건 a 태그를 사용해야 한다. 그래야 스크린리더가 링크라고 읽기 때문
- button : 버튼, UI적인 변화나 혹은 인터랙션을 유발할 수 있는 부분은 무조건 button 태그를 사용해야 한다. 그래야 스크린리더가 버튼이라고 읽기 때문
- section : 섹션 구획을 나눌때 사용하고, 적절한 role, aria-label 설정으로 어떤 Section인지 설명할 수 있도록 한다.
- article : 섹션 내부에 독립된 기능단위 UI를 만들 때 사용하고 적절한 aria-label 설정을 해준다.
- list : ol, li 같은 태그를 사용해 같은 리스트 안의 내용들이 인식될 수 있도록 만든다
- form : 유저 입력이 있는 부분은 form 태그로 감싸 어디서부터 어디까지 폼 형식인지 표현하고, input 태그와 같은 경우는 title
을 설정하여 어떤 입력란인지 설명하도록 한다.
- alert role : form을 입력할 때 유저 에러를 명시적으로 표시하고, 이런 메시지를 alert role로 설정하여 스크린리더가 인식할 수
있도록 만든다.
- heading : section 안에는 기본적으로 헤딩 태그를 꼭 포함하여 헤딩 태그로 건너뛸 수 있도록 한다. heading 태그가 디자인상
꼭 필요하지 않을 경우 CSS를 통해 시각적으로는 없애지만 마크업 내부에는 존재할 수 있도록 만든다.
- main : 스크린리더는 바로 main태그를 찾아 넘어가는 기능이 있는 경우도 있기 때문에 가장 중요한 부분을 main으로 감싼다
- aria-hidden의 적절한 이용 : 종강시계 앱은 페이지가 딱 하나고 스크롤로 다른 기능으로 넘어가는 UI가 있기 때문에, 스크롤로
같은 페이지의 다른 View로 넘어갔을 때 view 바깥의 요소에 스크린리더가 접근할 수 없도록 aria-hidden 태그를 동적으로 적용한다
탭 같은 경우도 탭을 열었을 때 다른 태그들에 접근할 수 없도록 aria-hidden을 이용해 다른 컨텐츠로 넘어가는 것을 방지한다.
- img alt : 이미지에 대체 택스트를 적용하여 src를 읽는 경우를 방지한다. 별 의미없는 이미지의 경우 alt에 '', 빈값을 적용한다.
- 태그 중첩에 신경쓴다.
